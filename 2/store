#!/usr/bin/env python3

"""
Usage:
    {name} [--path=<path>] project new
    {name} [--path=<path>] project list
    {name} [--path=<path>] project <project-id>
    {name} [--path=<path>] node <node-id>
    {name} [--path=<path>] node <node-id> cat
    {name} test
"""


"""
cat
check
clone
delete
deps
h.sh
half.sh
help-commands
i
insert
new
pipe
project-delete
project-rename
project-select
refresh
repl
run
select
serve
tree
watch
"""


import logging
import ctypes
import time
import json
import sys

import docopt
import lmdb


log = logging.getLogger(__name__)


class Fity3(ctypes.Structure):
    _fields_ = [
        ('sequence', ctypes.c_uint),
        ('last', ctypes.c_ulonglong), ]


class Fity3Exception(Exception):
    pass


class Flake(int):
    @staticmethod
    def from_bytes(key):
        return Flake(int.from_bytes(key, sys.byteorder))

    def to_bytes(self):
        return super().to_bytes(7, sys.byteorder)


# Wed, 15 Oct 2014 11:00:00.000 GMT
fitepoch = 1413370800000

worker_id_bits = 8
max_worker_id = -1 ^ (-1 << worker_id_bits)
sequence_bits = 4
worker_id_shift = sequence_bits
timestamp_left_shift = sequence_bits + worker_id_bits
sequence_mask = -1 ^ (-1 << sequence_bits)
timestamp_mask = -1 >> timestamp_left_shift << timestamp_left_shift


def to_timestamp(_id):
    _id = _id >> timestamp_left_shift  # strip the lower bits
    _id += fitepoch                    # adjust for epoch
    _id = _id / 1000                   # convert from milliseconds to seconds
    return _id


def next_flake(
        wx,
        key,
        worker_id,
        sleep=lambda x: time.sleep(x/1000.0),
        now=lambda: int(time.time()*1000)):

    assert worker_id >= 0 and worker_id <= max_worker_id

    try:
        state = wx.get(key)
        if not state:
            state = Fity3()
        else:
            state = Fity3.from_buffer_copy(state)

        timestamp = now()

        if state.last > timestamp:
            raise Fity3Exception(
                'clock is moving backwards. waiting until {}'.format(
                    state.last),
                state.last - timestamp)

        if state.last == timestamp:
            state.sequence = (state.sequence + 1) & sequence_mask
            if state.sequence == 0:
                raise Fity3Exception('sequence overrun', 1)
        else:
            state.sequence = 0

        state.last = timestamp

        wx.put(key, state)

        return Flake(
            ((timestamp-fitepoch) << timestamp_left_shift) |
            (worker_id << worker_id_shift) |
            state.sequence)

    except Fity3Exception as e:
        message, wait = e.args
        log.warning(message)
        sleep(wait)
        return next_flake(wx, key, worker_id, sleep=sleep, now=now)


def prefix_iter(rx, prefix):
    ret = []
    with rx.cursor() as c:
        if not c.set_range(prefix):
            return ret
        for key, value in c.iternext():
            if not key.startswith(prefix):
                break
            ret.append((key[len(prefix):], value))
    return ret


def node_new(wx, project):
    flake = next_flake(wx, b'mflake', 0)
    wx.put(b'o'+project.to_bytes()+b'nodes'+flake.to_bytes())
    wx.put(b'o'+flake.to_bytes()+b'run', b'echo Hello, world.')
    return flake


def node_get(rx, flake):
    ret = {}
    for key, value in prefix_iter(rx, b'o'+flake.to_bytes()):
        ret[key.decode()] = value.decode()
    return ret


def node_update(wx, flake, data):
    for name in data:
        wx.put(b'o'+flake.to_bytes()+name.encode(), data[name].encode())


def project_new(wx):
    flake = next_flake(wx, b'mflake', 0)
    wx.put(b'p'+flake.to_bytes())
    wx.put(b'o'+flake.to_bytes()+b'name', b'unnamed')
    node_new(wx, flake)
    return flake


def project_get(rx, flake):
    ret = {'nodes': []}
    for key, value in prefix_iter(rx, b'o'+flake.to_bytes()):
        if key == b'name':
            ret['name'] = value.decode()
        else:
            ret['nodes'].append(Flake.from_bytes(key[len('nodes'):]))
    return ret


def project_list(rx):
    products = prefix_iter(rx, b'p')
    ret = {}
    for key, _ in  products:
        flake = Flake.from_bytes(key[:7])
        ret[flake] = project_get(rx, flake)
    return ret


def project(env, a):
    if a.get('new'):
        with env.begin(write=True) as wx:
            flake = project_new(wx)
            return flake

    if a.get('list'):
        with env.begin() as rx:
            return project_list(rx)

    with env.begin() as rx:
        project = project_get(rx, Flake(a['<project-id>']))
        ret = {}
        for flake in project['nodes']:
            ret[flake] = node_get(rx, flake)
        return ret


def node(env, a, stdin=None):
    if a.get('cat'):
        if not stdin:
            stdin = sys.stdin.read()
        with env.begin(write=True) as wx:
            flake = Flake(a['<node-id>'])
            node_update(wx, flake, {'run': stdin})

    with env.begin() as rx:
        key = Flake(a['<node-id>'])
        return node_get(rx, key)


def test(a):
    import tempfile
    import shutil
    try:
        path = tempfile.mkdtemp()
        env = lmdb.open(path)
        flake = project(env, {'new': True})
        assert flake in project(env, {'list': True})
        nodes = project(env, {'<project-id>': flake})
        for flake in nodes:
            assert (
                node(env, {'<node-id>': flake})['run'] ==
                'echo Hello, world.')
            node(
                env,
                {'<node-id>': flake, 'cat': True},
                stdin='echo foo bar')
            assert (
                node(env, {'<node-id>': flake})['run'] ==
                'echo foo bar')
    finally:
        shutil.rmtree(path)
    return True


def main(a):
    env = lmdb.open('foo')

    if a['test']:
        return test(a)

    if a['project']:
        return project(env, a)

    if a['node']:
        return node(env, a)


if __name__ == '__main__':
    usage = ' '.join([x.strip() for x in __doc__.split('\\')])
    usage = usage.format(name=sys.argv[0])
    a = docopt.docopt(usage)
    print(json.dumps(main(a)))
