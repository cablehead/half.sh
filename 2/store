#!/usr/bin/env python3

"""
Usage:
    {name} project create
    {name} project list
"""


import logging
import ctypes
import time
import sys

import docopt
import lmdb


log = logging.getLogger(__name__)


class Fity3(ctypes.Structure):
    _fields_ = [
        ('sequence', ctypes.c_uint),
        ('last', ctypes.c_ulonglong), ]


class Fity3Exception(Exception):
    pass


class Flake(int):
    def to_bytes(self):
        return super().to_bytes(7, sys.byteorder)


# Wed, 15 Oct 2014 11:00:00.000 GMT
fitepoch = 1413370800000

worker_id_bits = 8
max_worker_id = -1 ^ (-1 << worker_id_bits)
sequence_bits = 4
worker_id_shift = sequence_bits
timestamp_left_shift = sequence_bits + worker_id_bits
sequence_mask = -1 ^ (-1 << sequence_bits)
timestamp_mask = -1 >> timestamp_left_shift << timestamp_left_shift


def to_timestamp(_id):
    _id = _id >> timestamp_left_shift  # strip the lower bits
    _id += fitepoch                    # adjust for epoch
    _id = _id / 1000                   # convert from milliseconds to seconds
    return _id


def next_flake(
        wx,
        key,
        worker_id,
        sleep=lambda x: time.sleep(x/1000.0),
        now=lambda: int(time.time()*1000)):

    assert worker_id >= 0 and worker_id <= max_worker_id

    try:
        state = wx.get(key)
        if not state:
            state = Fity3()
        else:
            state = Fity3.from_buffer_copy(state)

        timestamp = now()

        if state.last > timestamp:
            raise Fity3Exception(
                'clock is moving backwards. waiting until {}'.format(
                    state.last),
                state.last - timestamp)

        if state.last == timestamp:
            state.sequence = (state.sequence + 1) & sequence_mask
            if state.sequence == 0:
                raise Fity3Exception('sequence overrun', 1)
        else:
            state.sequence = 0

        state.last = timestamp

        wx.put(key, state)

        return Flake(
            ((timestamp-fitepoch) << timestamp_left_shift) |
            (worker_id << worker_id_shift) |
            state.sequence)

    except Fity3Exception as e:
        message, wait = e.args
        log.warning(message)
        sleep(wait)
        return next_flake(wx, key, worker_id, sleep=sleep, now=now)


def prefix_iter(rx, prefix):
    ret = []
    with rx.cursor() as c:
        if not c.set_range(prefix):
            return ret
        for key, value in c.iternext():
            if not key.startswith(prefix):
                break
            ret.append((key[len(prefix):], value))
    return ret


def node_new(wx, project):
    flake = next_flake(wx, b'mflake', 0)
    wx.put(b'o'+project.to_bytes()+b'nodes'+flake.to_bytes())
    wx.put(b'o'+flake.to_bytes()+b'run', b'echo Hello, world.')
    return flake


def project_new(wx):
    flake = next_flake(wx, b'mflake', 0)
    wx.put(b'p'+flake.to_bytes())
    wx.put(b'o'+flake.to_bytes()+b'name', b'unnamed')
    node_new(wx, flake)
    return flake


def project_get(rx, key):
    ret = {'nodes': []}
    for key, value in prefix_iter(rx, b'o'+key):
        if key == b'name':
            ret['name'] = value.decode()
        else:
            ret['nodes'].append(key[len('nodes'):])
    return ret


def project_list(rx):
    products = prefix_iter(rx, b'p')
    for key, _ in  products:
        flake = int.from_bytes(key[:7], sys.byteorder)
        project = project_get(rx, key)
        print(flake, project['name'], len(project['nodes']))


def main(a):
    assert a['project']

    env = lmdb.open('foo')

    if a['create']:
        with env.begin(write=True) as wx:
            flake = project_new(wx)
            print(flake)
            return

    if a['list']:
        with env.begin() as rx:
            project_list(rx)
            return


if __name__ == '__main__':
    usage = ' '.join([x.strip() for x in __doc__.split('\\')])
    usage = usage.format(name=sys.argv[0])
    a = docopt.docopt(usage)
    sys.exit(main(a))
