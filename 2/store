#!/usr/bin/env python3

"""
Usage:
    {name} test
    {name} [--path=<path>] tree
    {name} [--path=<path>] project new
    {name} [--path=<path>] project list
    {name} [--path=<path>] project <project-id>
    {name} [--path=<path>] project <project-id> delete
    {name} [--path=<path>] node <node-id>
    {name} [--path=<path>] node <node-id> cat
    {name} [--path=<path>] node <node-id> run
"""


import subprocess
import tempfile
import logging
import base64
import shutil
import ctypes
import time
import json
import sys
import os

import docopt
import psutil
import lmdb


"""
deps
check

half.sh
help-commands
repl

cat     # tick
i       # tick
run     # tick

# in progress
serve
tree

clone
delete
insert
pipe

select
watch
refresh

new
project-delete
project-rename
project-select
"""


log = logging.getLogger(__name__)


class Fity3(ctypes.Structure):
    _fields_ = [
        ('sequence', ctypes.c_uint),
        ('last', ctypes.c_ulonglong), ]


class Fity3Exception(Exception):
    pass


class Flake(int):
    @staticmethod
    def from_bytes(key):
        return Flake(int.from_bytes(key, sys.byteorder))

    def to_bytes(self):
        return super().to_bytes(7, sys.byteorder)


# Wed, 15 Oct 2014 11:00:00.000 GMT
fitepoch = 1413370800000

worker_id_bits = 8
max_worker_id = -1 ^ (-1 << worker_id_bits)
sequence_bits = 4
worker_id_shift = sequence_bits
timestamp_left_shift = sequence_bits + worker_id_bits
sequence_mask = -1 ^ (-1 << sequence_bits)
timestamp_mask = -1 >> timestamp_left_shift << timestamp_left_shift


def to_timestamp(_id):
    _id = _id >> timestamp_left_shift  # strip the lower bits
    _id += fitepoch                    # adjust for epoch
    _id = _id / 1000                   # convert from milliseconds to seconds
    return _id


def next_flake(
        wx,
        key,
        worker_id,
        sleep=lambda x: time.sleep(x/1000.0),
        now=lambda: int(time.time()*1000)):

    assert worker_id >= 0 and worker_id <= max_worker_id

    try:
        state = wx.get(key)
        if not state:
            state = Fity3()
        else:
            state = Fity3.from_buffer_copy(state)

        timestamp = now()

        if state.last > timestamp:
            raise Fity3Exception(
                'clock is moving backwards. waiting until {}'.format(
                    state.last),
                state.last - timestamp)

        if state.last == timestamp:
            state.sequence = (state.sequence + 1) & sequence_mask
            if state.sequence == 0:
                raise Fity3Exception('sequence overrun', 1)
        else:
            state.sequence = 0

        state.last = timestamp

        wx.put(key, state)

        return Flake(
            ((timestamp-fitepoch) << timestamp_left_shift) |
            (worker_id << worker_id_shift) |
            state.sequence)

    except Fity3Exception as e:
        message, wait = e.args
        log.warning(message)
        sleep(wait)
        return next_flake(wx, key, worker_id, sleep=sleep, now=now)


def prefix_iter(rx, prefix):
    ret = []
    with rx.cursor() as c:
        if not c.set_range(prefix):
            return ret
        for key, value in c.iternext():
            if not key.startswith(prefix):
                break
            ret.append((key[len(prefix):], value))
    return ret


def node_new(wx, project):
    flake = next_flake(wx, b'mflake', 0)
    wx.put(b'o'+project.to_bytes()+b'nodes'+flake.to_bytes())
    wx.put(b'o'+flake.to_bytes()+b'run', b'echo Hello, world.')
    return flake


def node_get(rx, flake):
    ret = {'ticks': []}
    for key, value in prefix_iter(rx, b'o'+flake.to_bytes()):
        if key.startswith(b'tick'):
            value = json.loads(value)
            value['tick_id'] = Flake.from_bytes(key[4:])
            ret['ticks'].append(value)
        else:
            ret[key.decode()] = value.decode()
    ret['ticks'].sort(key=lambda x: x['tick_id'])
    return ret


def node_delete(wx, flake):
    for key, value in prefix_iter(wx, b'o'+flake.to_bytes()):
        wx.delete(b'o'+flake.to_bytes()+key)


def node_update(wx, flake, data):
    for name in data:
        wx.put(b'o'+flake.to_bytes()+name.encode(), data[name].encode())


def project_new(wx):
    flake = next_flake(wx, b'mflake', 0)
    wx.put(b'p'+flake.to_bytes())
    wx.put(b'o'+flake.to_bytes()+b'name', b'unnamed')
    node_new(wx, flake)
    return flake


def project_get(rx, flake):
    ret = {'nodes': []}
    for key, value in prefix_iter(rx, b'o'+flake.to_bytes()):
        if key == b'name':
            ret['name'] = value.decode()
        else:
            ret['nodes'].append(Flake.from_bytes(key[len('nodes'):]))
    return ret


def project_list(rx):
    products = prefix_iter(rx, b'p')
    ret = {}
    for key, _ in products:
        flake = Flake.from_bytes(key[:7])
        ret[flake] = project_get(rx, flake)
    return ret


def project(env, a):
    if a.get('new'):
        with env.begin(write=True) as wx:
            flake = project_new(wx)
            return flake

    if a.get('list'):
        with env.begin() as rx:
            return project_list(rx)

    if a.get('delete'):
        with env.begin(write=True) as wx:
            for key, value in prefix_iter(wx, b''):
                print(key, value)
            project_id = Flake(a['<project-id>'])
            project = project_get(wx, project_id)
            for node_id in project['nodes']:
                node_delete(wx, node_id)
            for key, value in prefix_iter(wx, b'o'+project_id.to_bytes()):
                wx.delete(b'o'+project_id.to_bytes()+key)
            wx.delete(b'p'+project_id.to_bytes())
            print()
            print()
            for key, value in prefix_iter(wx, b''):
                print(key, value)
        return

    with env.begin() as rx:
        project = project_get(rx, Flake(a['<project-id>']))
        ret = {}
        for flake in project['nodes']:
            ret[flake] = node_get(rx, flake)
        return ret


def node(env, a, stdin=None):
    flake = Flake(a['<node-id>'])

    if a.get('run'):
        try:
            path = tempfile.mkdtemp()

            with env.begin(write=True) as wx:
                node = node_get(wx, flake)

                if node['ticks']:
                    tick = node['ticks'][-1]
                    if 'pid' in tick:
                        # still running?
                        if psutil.pid_exists(tick['pid']):
                            return
                        # runner must have died
                        wx.delete(
                            b'o'+flake.to_bytes() + b'tick' +
                            Flake(tick['tick_id']).to_bytes())

                with open(
                        os.open(
                            path+'/run', os.O_CREAT | os.O_WRONLY, 0o777),
                        'w') as fh:
                    fh.write(node['run'])

                p = subprocess.Popen(
                        path+'/run',
                        shell=True,
                        stdin=subprocess.DEVNULL,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        )

                tick_id = next_flake(wx, b'mflake', 0)
                wx.put(
                    b'o'+flake.to_bytes()+b'tick'+tick_id.to_bytes(),
                    json.dumps({'pid': p.pid}).encode())

            # end write transation

            res = {}
            res['stdout'] = p.stdout.read().decode()
            res['stderr'] = p.stderr.read().decode()
            res['exitcode'] = p.wait()
            res = json.dumps(res).encode()

            with env.begin(write=True) as wx:
                node = node_get(wx, flake)
                if not node:
                    return
                wx.put(
                    b'o'+flake.to_bytes()+b'tick'+tick_id.to_bytes(),
                    res)
                # only keep the last two results
                for tick in node['ticks'][:-2]:
                    wx.delete(
                        b'o' + flake.to_bytes() + b'tick' +
                        Flake(tick['tick_id']).to_bytes())

        finally:
            shutil.rmtree(path)

    if a.get('cat'):
        if not stdin:
            stdin = sys.stdin.read()
        with env.begin(write=True) as wx:
            node_update(wx, flake, {'run': stdin})

    with env.begin() as rx:
        return node_get(rx, flake)


def test(a):
    try:
        path = tempfile.mkdtemp()
        env = lmdb.open(path)
        flake = project(env, {'new': True})
        assert flake in project(env, {'list': True})
        nodes = project(env, {'<project-id>': flake})
        for flake in nodes:
            assert (
                node(env, {'<node-id>': flake})['run'] ==
                'echo Hello, world.')
            node(
                env,
                {'<node-id>': flake, 'cat': True},
                stdin='echo foo bar')
            assert (
                node(env, {'<node-id>': flake})['run'] ==
                'echo foo bar')
    finally:
        shutil.rmtree(path)
    return True


def tree(env, a):
    ret = {'project': {}}
    with env.begin() as rx:
        projects = project_list(rx)
        for project_id, project in projects.items():
            P = {'name': project['name'], 'node': {}}
            for node_id in project['nodes']:
                node = node_get(rx, node_id)
                if node['ticks']:
                    P['node'][node_id] = {
                        'run': base64.b64encode(node['run'].encode()).decode(),
                        'stdin': 'dev',
                        'stdout': base64.b64encode(
                            node['ticks'][-1]['stdout'].encode()).decode(),
                        'stderr': base64.b64encode(
                            node['ticks'][-1]['stderr'].encode()).decode(),
                        'exitcode': node['ticks'][-1]['exitcode'], }
            ret['project'][project_id] = P
    return {'$set': ret}


def main(a):
    if a['test']:
        return test(a)

    env = lmdb.open('foo')

    if a['tree']:
        return tree(env, a)

    if a['project']:
        return project(env, a)

    if a['node']:
        return node(env, a)


if __name__ == '__main__':
    usage = ' '.join([x.strip() for x in __doc__.split('\\')])
    usage = usage.format(name=sys.argv[0])
    a = docopt.docopt(usage)
    ret = main(a)
    if ret is not None:
        print(json.dumps(ret))
