#!/usr/bin/env python3


print('----==----')

import logging
import ctypes
import time
import sys

import lmdb


log = logging.getLogger(__name__)


class Fity3(ctypes.Structure):
    _fields_ = [
        ('sequence', ctypes.c_uint),
        ('last', ctypes.c_ulonglong), ]


class Fity3Exception(Exception):
    pass


class Flake(int):
    def to_bytes(self):
        return super().to_bytes(7, sys.byteorder)


# Wed, 15 Oct 2014 11:00:00.000 GMT
fitepoch = 1413370800000

worker_id_bits = 8
max_worker_id = -1 ^ (-1 << worker_id_bits)
sequence_bits = 4
worker_id_shift = sequence_bits
timestamp_left_shift = sequence_bits + worker_id_bits
sequence_mask = -1 ^ (-1 << sequence_bits)
timestamp_mask = -1 >> timestamp_left_shift << timestamp_left_shift


def to_timestamp(_id):
    _id = _id >> timestamp_left_shift  # strip the lower bits
    _id += fitepoch                    # adjust for epoch
    _id = _id / 1000                   # convert from milliseconds to seconds
    return _id


def next_flake(
        env,
        key,
        worker_id,
        sleep=lambda x: time.sleep(x/1000.0),
        now=lambda: int(time.time()*1000)):

    assert worker_id >= 0 and worker_id <= max_worker_id

    try:
        with env.begin(write=True) as txn:
            state = txn.get(key)
            if not state:
                state = Fity3()
            else:
                state = Fity3.from_buffer_copy(state)

            timestamp = now()

            if state.last > timestamp:
                raise Fity3Exception(
                    'clock is moving backwards. waiting until {}'.format(
                        state.last),
                    state.last - timestamp)

            if state.last == timestamp:
                state.sequence = (state.sequence + 1) & sequence_mask
                if state.sequence == 0:
                    raise Fity3Exception('sequence overrun', 1)
            else:
                state.sequence = 0

            state.last = timestamp

            txn.put(key, state)

            return Flake(
                ((timestamp-fitepoch) << timestamp_left_shift) |
                (worker_id << worker_id_shift) |
                state.sequence)

    except Fity3Exception as e:
        message, wait = e.args
        log.warning(message)
        sleep(wait)


env = lmdb.open('foo')

flake = next_flake(env, b'mflake', 0)


def prefix_iter(env, prefix):
    print('prefix', prefix)
    i = int.from_bytes(prefix, sys.byteorder)
    i += 1
    end = i.to_bytes(len(prefix)+1, sys.byteorder)
    ret = []
    with env.begin() as txn:
        with txn.cursor() as c:
            if not c.set_range(prefix):
                return ret
            for key, value in c.iternext():
                if key >= end:
                    break
                print('found', key)
                ret.append((key[len(prefix):], value))
    return ret


def node_new(env, project):
    flake = next_flake(env, b'mflake', 0)
    with env.begin(buffers=True, write=True) as txn:
        txn.put(b'p'+flake.to_bytes(), b'')
        txn.put(b'o'+project.to_bytes()+b'nodes'+flake.to_bytes())
        txn.put(b'o'+flake.to_bytes()+b'run', b'echo Hello, world.')
    return flake


def project_new(env):
    flake = next_flake(env, b'mflake', 0)
    with env.begin(buffers=True, write=True) as txn:
        txn.put(b'p'+flake.to_bytes())
        txn.put(b'o'+flake.to_bytes()+b'name', b'unnamed')
        print(1)
        # node_new(env, flake)
        print(2)
    return flake


def project_list(env):
    products = prefix_iter(env, b'p')
    for key, value in  products:
        with env.begin() as txn:
            print('list', len(key), key, txn.get(b'o'+key+b'name'))


project_list(env)
print('..')
project_new(env)


